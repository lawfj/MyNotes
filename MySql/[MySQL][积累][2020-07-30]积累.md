# 对比数据是否一致
比对数据是否一致可以通过MD5、长度、十六进制多个维度进行比对。
1、长度
```
# 返回字符串的字符数，如果是数值，会转换成字符串再计算长度
select length('aaa');
select length(1234); //结果为4
```
2、十六进制
```
# 第三项1为相等，0为不相等
SELECT HEX(t1.a),HEX(t2.a),HEX(t1.a)=HEX(t2.a) from t1,t2;
```
3、MD5
```sql
mysql> select md5(123);
+----------------------------------+
| md5(123)                         |
+----------------------------------+
| 202cb962ac59075b964b07152d234b70 |
+----------------------------------+
1 row in set (0.01 sec)

mysql> select md5('123');
+----------------------------------+
| md5('123')                       |
+----------------------------------+
| 202cb962ac59075b964b07152d234b70 |
+----------------------------------+
1 row in set (0.00 sec)
```
![title](https://raw.githubusercontent.com/lawfj/MyNotesPic/master/MyNotes/2020/07/30/1596115797895-1596115797923.png)


案例
对比两张表的数据是否一致
```bash
#!/bin/bash

mysql_user=root
mysql_passwd=root
mysql_host=127.0.0.1
mysql_port=3306

table_schema_1=tt
table_name_1=t1
table_schema_2=tt
table_name_2=t2

# 获取列名，因为两个表的表结构完全一样，所以只需要获取一次就行
sql_col=""
for col in `mysql -u${mysql_user} -p${mysql_passwd} -h${mysql_host} -P${mysql_port} -Nse "select column_name from infomation_schema.columns where table_schema='${table_schema_1}' and table_name='${table_name}'"`; do
    sql_col=${sql_col}"ifnull(${col},''),"
done

# 根据上面获取到的列名，拼接md5的sql语句
sql_1="select md5(concat(${sql_col%?})) as md5_value from ${table_schema_1}.${table_name_1};"
sql_2="select md5(concat(${sql_col%?})) as md5_value from ${table_schema_2}.${table_name_2};"

获取两张表每一行的MD5值，写入文件待对比
mysql -u${mysql_user} -p${mysql_passwd} -h${mysql_host} -P${mysql_port} -Nse "${sql_1}" > result_1.out
mysql -u${mysql_user} -p${mysql_passwd} -h${mysql_host} -P${mysql_port} -Nse "${sql_2}" > result_2.out

# 对比两个文件，diff命令，完全相同返回0，不同的话返回第一处不同的地方的行数
diff result_1.out result_2.out
if [ $? -et 0 ]; then
    echo "The contents of the two tables are exactly the same."
fi
rm -f resut_1.out result_2.out
```
# innodb_force_recovery
只有在需要从错误状态的数据库进行数据备份时，才建议设置innodb_force_recovery的值大于0。

0 —正常的关闭和启动，不会做任何强迫恢复操作；

1 —跳过错误页，让mysqld服务继续运行。跳过错误索引记录和存储页，尝试用

SELECT * INOT OUTFILE ‘../filename’ FROM tablename;方式，完成数据备份；

2 —阻止InnoDB的主线程运行。清理操作时出现mysqld服务崩溃，则会阻止数据恢复操作；

3 —恢复的时候，不进行事务回滚；

4 —阻止INSERT缓冲区的合并操作。不做合并操作，为防止出现mysqld服务崩溃。不计算表的统计信息

5 — mysqld服务启动的时候不检查回滚日志：InnoDB引擎对待每个不确定的事务就像提交的事务一样；

6 —不做事务日志前滚恢复操作；
# 主备
备库回放sql，也是会写binlog的，所以半同步如果慢的话，有个可能是备库落盘慢。
# 关于timestamp默认值
1) create table t_ts(t timestamp);
2) create table t_ts(t timestamp on update current_timestamp);
3) create table t_ts(t timestamp default current_timestamp);
4) create table t_ts(t timestamp default current_timestamp on update current_timestamp);
5) create table t_ts(t timestamp default 'yyyy-mm-dd hh:mm:ss' on update current_timestamp);
6) create table t_ts(t timestamp(6));
7) create table t_ts(t timestamp(6) on update current_timestamp(6));
8) create table t_ts(t timestamp(6) default current_timestamp(6));
9) create table t_ts(t timestamp(6) default current_timestamp on update current_timestamp(6));
10) create table t_ts(t timestamp(6) default 'yyyy-mm-dd hh:mm:ss' on update current_timestamp(6));

```

